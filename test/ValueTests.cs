
/* Original code[1] Copyright (c) 2022 Shane Celis[2]
   Licensed under the MIT License[3]

   This comment generated by code-cite[3].

   [1]: https://github.com/shanecelis/SeawispHunter.RolePlay.Attributes
   [2]: https://twitter.com/shanecelis
   [3]: https://opensource.org/licenses/MIT
   [4]: https://github.com/shanecelis/code-cite
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.ComponentModel;
using Xunit;

using SeawispHunter.RolePlay.Attributes;
namespace SeawispHunter.RolePlay.Attributes.Test {

public class ValueTests {
  Value<int> a = new Value<int>();
  [Fact] public void TestValueSelect() {
    var b = a.Select(x => x + 1, (v, x) => v.value = x - 1);
    Assert.Equal(0, a.value);
    Assert.Equal(1, b.value);
    a.value = 2;

    Assert.Equal(2, a.value);
    Assert.Equal(3, b.value);
    b.value = 3;
    Assert.Equal(2, a.value);
    Assert.Equal(3, b.value);
    b.value = 4;
    Assert.Equal(3, a.value);
    Assert.Equal(4, b.value);
  }

  [Fact] public void TestBoundedInputValue() {
    var v = new ModifiableValue<float>(new BoundedValue<float>(100f, 0f, 100f));
    v.modifiers.Add(Modifier.Plus(10f));
    Assert.Equal(110f, v.value);
    v.initial.value = 200f;
    Assert.Equal(110f, v.value);
  }

  [Fact] public void TestBoundedInputValueConstructor() {
    var v = new ModifiableValue<float>(new BoundedValue<float>(110f, 0f, 100f));
    Assert.Equal(100f, v.value);
  }

  [Fact] public void TestBoundedOutputValue() {
    var v = new BoundedModifiable<IValue<float>,float>(new Value<float>(100f), 0f, 100f);
    v.modifiers.Add(Modifier.Plus(10f));
    Assert.Equal(100f, v.value);
    v.initial.value = 200f;
    Assert.Equal(100f, v.value);
  }

  [Fact] public void TestHp() {
    var hp = new BoundedModifiable<IValue<float>,float>(new Value<float>(50f), 0f, 100f);
    Assert.Equal(50f, hp.value);
    var ring = Modifier.Plus(10f);
    hp.modifiers.Add(ring);
    Assert.Equal(60f, hp.value);
    hp.initial.value -= 5f;
    Assert.Equal(55f, hp.value);
    hp.modifiers.Remove(ring);
    Assert.Equal(45f, hp.value);
  }

  [Fact] public void TestMaxHp() {
    var maxHp = new ModifiableValue<float>(100f);
    var damage = new Value<float>(50);
    var hp = maxHp.Zip(damage, (maxHp, damage) => maxHp - damage);
    Assert.Equal(50f, hp.value);
    var ring = Modifier.Plus(10f);
    maxHp.modifiers.Add(ring);
    Assert.Equal(60f, hp.value);
    damage.value += 5f;
    Assert.Equal(55f, hp.value);
    maxHp.modifiers.Remove(ring);
    Assert.Equal(45f, hp.value);
  }

  [Fact] public void TestMaxHpBounded()
  {
    var maxHp = new ModifiableValue<float>(100f);
    var damage = new BoundedValue<float>(50, 0f, maxHp);
    var hp = maxHp.Zip(damage, (maxHp, damage) => maxHp - damage);
    Assert.Equal(50f, hp.value);  //  (maxHp : 100) - (damage : 50) = 50
    var ring = Modifier.Plus(10f);
    maxHp.modifiers.Add(ring);
    Assert.Equal(60f, hp.value); //  (maxHp : 100) - (damage : 50) + (ring :10) = 60
    damage.value += 5f;
    Assert.Equal(55f, hp.value); //  (maxHp : 100) - (damage : 55) + (ring :10) = 55
    maxHp.modifiers.Remove(ring);
    Assert.Equal(45f, hp.value); //  (maxHp : 100) - (damage : 55) = 45
    damage.value -= 100f; // Heal 100 / Intent to heel the opposite of damage without affecting maxHp
    Assert.Equal(100f, hp.value); // damage bounded to 0.
    damage.value += 5f;
    Assert.Equal(95f, hp.value); // No weird internal state effects where damage internally is -45.
  }

  interface IModifierId {
    public int id { get; } // Use UUID, bit flags, enum, whatever you want.
    public const int RING = 101;
  }

  class Ring: IModifier<float>, IModifierId {
    public enum Worn {
      None,
      Left,
      Right,
      Toe
    };
    public Worn worn = Worn.None;
    float addHealth;
    public int id => IModifierId.RING;
    public bool enabled { get; set; } = true;

    public Ring(float addHealth) => this.addHealth = addHealth;

    public float Modify(float given) => given + addHealth;

    public event PropertyChangedEventHandler PropertyChanged;
  }

  [Fact] public void TestModifierImplementer()
  {
    var maxHp = new ModifiableValue<float>(100f);
    var damage = new BoundedValue<float>(50, 0f, maxHp);
    var hp = maxHp.Zip(damage, (maxHp, damage) => maxHp - damage);
    Assert.Equal(50f, hp.value);  //  (maxHp : 100) - (damage : 50) = 50
    var ring = new Ring(10f);
    maxHp.modifiers.Add(ring);
    Assert.Equal(60f, hp.value); //  (maxHp : 100) - (damage : 50) + (ring :10) = 60
    damage.value += 5f;
    Assert.Equal(55f, hp.value); //  (maxHp : 100) - (damage : 55) + (ring :10) = 55
    // How to remove without knowing what's in there?
    ring = null;
    var rings = maxHp.modifiers
      .OfType<IModifierId>()
      .Where(m => m.id == IModifierId.RING)
      .ToList();
    foreach (var r in rings) {
      maxHp.modifiers.Remove((IModifier<float>) r);
    }
    Assert.Equal(45f, hp.value); //  (maxHp : 100) - (damage : 55) = 45
  }

  [Fact] public void TestLeftRingRemoval()
  {
    var maxHp = new ModifiableValue<float>(100f);
    var damage = new BoundedValue<float>(50, 0f, maxHp);
    var hp = maxHp.Zip(damage, (maxHp, damage) => maxHp - damage);
    Assert.Equal(50f, hp.value);  //  (maxHp : 100) - (damage : 50) = 50
    maxHp.modifiers.Add(new Ring(5f) { worn = Ring.Worn.Left });
    maxHp.modifiers.Add(new Ring(5f) { worn = Ring.Worn.Right });
    Assert.Equal(60f, hp.value); //  (maxHp : 100) - (damage : 50) + (ring :10) = 60
    damage.value += 5f;
    Assert.Equal(55f, hp.value); //  (maxHp : 100) - (damage : 55) + (ring :10) = 55
    // How to remove without knowing what's in there?
    var leftRing = maxHp.modifiers
      .OfType<Ring>()
      .Where(r => r.worn == Ring.Worn.Left)
      .Single();
    maxHp.modifiers.Remove((IModifier<float>) leftRing);
    Assert.Equal(50f, hp.value); //  (maxHp : 100) - (damage : 55) = 45
  }

  [Fact] public void TestBoundedInputOutputValue() {
  var v = new BoundedModifiable<IValue<float>,float>(new BoundedValue<float>(100f, 0f, 100f), 0f, 100f);
    v.modifiers.Add(Modifier.Plus(10f));
    Assert.Equal(100f, v.value);
    v.initial.value = 200f;
    Assert.Equal(100f, v.value);
  }
}
}
