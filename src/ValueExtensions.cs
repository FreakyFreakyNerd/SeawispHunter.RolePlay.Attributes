/* Original code[1] Copyright (c) 2022 Shane Celis[2]
   Licensed under the MIT License[3]

   This comment generated by code-cite[3].

   [1]: https://github.com/shanecelis/SeawispHunter.RolePlay.Attributes
   [2]: https://twitter.com/shanecelis
   [3]: https://opensource.org/licenses/MIT
   [4]: https://github.com/shanecelis/code-cite
*/
using System;

namespace SeawispHunter.RolePlay.Attributes;

public static class ValueExtensions {
  /** Give ourselves a little projection, as a treat. */
  public static IReadOnlyValue<T> Select<S,T>(this IReadOnlyValue<S> v, Func<S,T> func) {
    var w = Value.FromFunc(() => func(v.value), out var callOnChange);
    v.PropertyChanged += (_, _) => callOnChange();
    return w;
  }

  public static IReadOnlyValue<U> Zip<S,T,U>(this IReadOnlyValue<S> v, IReadOnlyValue<T> w, Func<S,T,U> func) {
    var u = Value.FromFunc(() => func(v.value, w.value), out var callOnChange);
    v.PropertyChanged += (_, _) => callOnChange();
    w.PropertyChanged += (_, _) => callOnChange();
    return u;
  }

  /* I don't know. This seems overly complicated. It's no longer projection, it's projection and an inverse/coalesce action. */
  public static IValue<T> Select<S,T>(this IValue<S> v, Func<S,T> @get, Action<IValue<S>,T> @set) {
    var w = Value.FromFunc(() => @get(v.value), x => @set(v, x), out var callOnChange);
    v.PropertyChanged += (_, _) => callOnChange();
    return w;
  }

  public static IModifier<Y> Cast<X,Y>(this IModifier<X> m)
#if NET6_0_OR_GREATER
    where X : INumber<X> where Y : INumber<Y>
#endif
  {
    return new Modifier.CastingModifier<X,Y>(m);
  }
}
